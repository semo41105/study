--SET OPERATOR--
--두 개 이상의 SELECT를 실행한 결과를
--합치는 집합 형태의 결과로 조회하는 명령어

--합집합--
--UNION: 두 개 이상의 SELECT한 결과(RESULTSET)를 구하는 명령어
--              두 개 이상의 결과를 보여주며 만약 중복되는 결과가 있을 경우 1번만 보여준다.
--UNION ALL : 두 개 이상의 SELECT한 결과를 구하는 명령어
--                       만약 중복이 있을 경우 중복되는 내용도 그대로 조회하여 보여준다.

--교집합--
--INTERSECT: 두 개 이상의 SELECT한 결과 중 중복되는 결과만을 보여준다.

--차집합--
--MINUS: 두 개 이상의 SELECT한 결과 중 첫번째 결과만이 가진 내용을 보여준다.

--합집합--
--UNION--
SELECT EMP_ID, EMP_NAME, DEPT_CODE, SALARY
FROM EMPLOYEE
WHERE DEPT_CODE = 'D5'

UNION--편의상 띄어쓰기 한 것임.

SELECT EMP_ID, EMP_NAME, DEPT_CODE, SALARY
FROM EMPLOYEE
WHERE SALARY>3000000;

--UNION ALL--
SELECT EMP_ID, EMP_NAME, DEPT_CODE, SALARY
FROM EMPLOYEE
WHERE DEPT_CODE = 'D5'

UNION ALL--편의상 띄어쓰기 한 것임.

SELECT EMP_ID, EMP_NAME, DEPT_CODE, SALARY
FROM EMPLOYEE
WHERE SALARY>3000000;

--
SELECT DEPT_CODE, JOB_CODE, SUM(SALARY)
FROM EMPLOYEE
GROUP BY DEPT_CODE, JOB_CODE
HAVING SUM(SALARY)>8000000
UNION
SELECT DEPT_CODE, JOB_CODE, SUM(SALARY)
FROM EMPLOYEE
GROUP BY DEPT_CODE, JOB_CODE
HAVING SUM(SALARY)<6000000;

--교집합--
--INTERSECT
SELECT EMP_ID, EMP_NAME, DEPT_CODE, SALARY
FROM EMPLOYEE
WHERE DEPT_CODE = 'D5'

INTERSECT

SELECT EMP_ID, EMP_NAME, DEPT_CODE, SALARY
FROM EMPLOYEE
WHERE SALARY>3000000;

--차집합--
--MINUS
SELECT EMP_ID, EMP_NAME, DEPT_CODE, SALARY
FROM EMPLOYEE
WHERE DEPT_CODE = 'D5'

MINUS

SELECT EMP_ID, EMP_NAME, DEPT_CODE, SALARY
FROM EMPLOYEE
WHERE SALARY>3000000;

--[JOIN]--
--두 개 이상의 테이블을 하나로 합쳐 사용하는 명령어

--'J6'라는 직급을 가진 사원들의 근무 부서명이 궁금하다...
SELECT EMP_NAME,JOB_CODE, DEPT_CODE
FROM EMPLOYEE
WHERE JOB_CODE = 'J6';

SELECT * FROM DEPARTMENT;

-- 오라클 전용 / ANSI 표준 문법 --

--오라클 전용 문법
--FROM 절에 ','를 붙여 합치게 될 테이블을 나열하고
--WHERE조건을 통해 합칠 테이블들의 공통 사항을 명시

SELECT EMP_ID, EMP_NAME, DEPT_CODE, DEPT_TITLE
FROM EMPLOYEE, DEPARTMENT
WHERE DEPT_CODE = DEPT_ID;

SELECT *
FROM EMPLOYEE, DEPARTMENT
WHERE DEPT_CODE = DEPT_ID;

--
SELECT * FROM EMPLOYEE;
SELECT * FROM JOB;

--EMPLOYEE 테이블과 JOB 테이블을 JOIN을 통해 
--사원번호, 사원명, 직급코드, 직급명을 조회해보자
SELECT EMP_ID, EMP_NAME, E.JOB_CODE, JOB_NAME
FROM EMPLOYEE E, JOB J
WHERE E.JOB_CODE = J.JOB_CODE;

-------
--ANSI 표준 문법--
--조인하고자 하는 테이블을 FROM 구문 다음에
--JOIN 테이블명 ON() || USING() 구문을 사용
--하여 합치는 방법

--두 개의 테이블에서 공통 컬럼의 이름이 다를 경우
SELECT EMP_ID, EMP_NAME, DEPT_CODE, DEPT_TITLE
FROM EMPLOYEE
--JOIN DEPARTMENT ON(EMPLOYEE.DEPT_CODE = DEPARTMENT.DEPT_ID);
JOIN DEPARTMENT ON(DEPT_CODE = DEPT_ID);

--두 개의 테이블에서 공통 컬럼의 이름이 같을 경우
--ON
SELECT EMP_ID, EMP_NAME, EMPLOYEE.JOB_CODE, JOB_NAME
FROM EMPLOYEE
JOIN JOB ON(EMPLOYEE.JOB_CODE = JOB.JOB_CODE);

--USING
SELECT EMP_ID, EMP_NAME, JOB_CODE, JOB_NAME
FROM EMPLOYEE
JOIN JOB USING(JOB_CODE);

--실습1.
--EMPLOYEE  테이블의 직원 급여 정보외
--SAL_GRADE의 급여 등급을 합쳐서
--사번, 사원명, 급여 등급, 등급 기준 최소 급여, 등급 기준 최대 급여를 조회

--연결하고자 하는 테이블 정보 조회
SELECT * FROM SAL_GRADE;
SELECT * FROM EMPLOYEE;

--ORACLE 구문--
SELECT EMP_ID, EMP_NAME, E.SAL_LEVEL, MIN_SAL, MAX_SAL
FROM EMPLOYEE E, SAL_GRADE S
WHERE E.SAL_LEVEL = S.SAL_LEVEL;

--ANSI 구문--
SELECT EMP_ID, EMP_NAME, EMPLOYEE.SAL_LEVEL, MIN_SAL, MAX_SAL
FROM EMPLOYEE
JOIN SAL_GRADE ON(EMPLOYEE.SAL_LEVEL = SAL_GRADE.SAL_LEVEL);

--실습2
--DEPARTMENT 테이블의 위치 정보와
--LOCATION 테이블을 조인하여
--각 부서별 근무지 위치를 조회
--부서코드, 부서명, 근무지 코드, 근무지 위치

SELECT * FROM DEPARTMENT;
SELECT * FROM LOCATION;

--ORACLE 구문--
SELECT DEPT_ID, DEPT_TITLE, LOCATION_ID,  LOCAL_NAME
FROM DEPARTMENT , LOCATION 
WHERE LOCATION_ID = LOCAL_CODE;

--ANSI 구문--
SELECT DEPT_ID, DEPT_TITLE, LOCATION_ID,  LOCAL_NAME
FROM DEPARTMENT
JOIN LOCATION ON(LOCATION_ID = LOCAL_CODE);

----------------------------------
--INNER JOIN / OUTER JOIN
--두 개 이상의 테이블을 하나로 합칠 때
--INNER JOIN은 둘 모두 일치하는 데이터만 합치고,
--OUTER JOIN은 둘 중 하나, 혹은 둘 모두가 가진 값을 합칠 때 사용한다.

--INNER JOIN
SELECT DEPT_TITLE
FROM EMPLOYEE
JOIN DEPARTMENT ON(DEPT_CODE = DEPT_ID);

--OUTER JOIN
--LEFT [OUTER] JOIN : 두 테이블 중 원본(좌측) 테이블의 정보를 모두 포함하여 조회

--RIGHT [OUTER] JOIN : 두 테이블 중 JOIN에 명시한 테이블의 정보를 모두 포함하여 조회

--FULL [OUTER] JOIN : 두 테이블이 가진 데이터 중 서로가 가지지 않은 값일지라도 모두 포함하여 조회

--LEFT JOIN--
--ANSI
SELECT DEPT_CODE, EMP_NAME, DEPT_TITLE
FROM EMPLOYEE
LEFT JOIN DEPARTMENT ON(DEPT_CODE = DEPT_ID);

--ORACLE
SELECT DEPT_CODE, EMP_NAME, DEPT_TITLE
FROM EMPLOYEE, DEPARTMENT
WHERE DEPT_CODE = DEPT_ID(+);

--RIGHT JOIN--
SELECT DISTINCT DEPT_CODE FROM EMPLOYEE;
SELECT * FROM DEPARTMENT;

--ANSI
SELECT DEPT_CODE, DEPT_ID, EMP_NAME
FROM EMPLOYEE
RIGHT JOIN DEPARTMENT ON(DEPT_CODE = DEPT_ID);

SELECT *
FROM EMPLOYEE
RIGHT JOIN DEPARTMENT ON(DEPT_CODE = DEPT_ID);

--ORACLE
SELECT DEPT_CODE, DEPT_ID, EMP_NAME
FROM EMPLOYEE, DEPARTMENT
WHERE DEPT_CODE(+) = DEPT_ID;

--FULL JOIN--
--ANSI 
SELECT DEPT_CODE, DEPT_ID, EMP_NAME
FROM EMPLOYEE
FULL JOIN DEPARTMENT ON(DEPT_CODE = DEPT_ID);

--ORACLE : 오라클 구문에서는 FULL OUTER JOIN을 지원하지 않는다. 오류 발생.
SELECT DEPT_CODE, DEPT_ID, EMP_NAME
FROM EMPLOYEE, DEPARTMENT
WHERE DEPT_CODE(+) = DEPT_ID(+) ;


--CROSS JOIN--
--기본적인 JOIN은 양측의 테이블에서 일치하는 정보를 가지고 JOIN을 수행, 이를 EQ(Equal) JOIN
--하지만, 서로 같은 값을 가지지 않는 테이블의 정보를 조회하려고 할 경우에도 JOIN을 수행할 수 있다.
--이러한 조인 방식을 CROSS JOIN

SELECT EMP_NAME, NATIONAL_CODE
FROM EMPLOYEE
CROSS JOIN NATIONAL;

SELECT * FROM NATIONAL;


--NON-EQUAL JOIN(NON-EQ JOIN)
--지정한 컬럼 값 자체가 아닌 특정 범위 내에 존재하는 조건으로 JOIN을 수행하는 경우

--ON() 안에 들어가는 형식이 컬럼뿐만 아니라 계산식, 함수식, AND, OR등의 조건식을 넣을 수 있다.

SELECT EMP_NAME, DEPT_CODE, SALARY, E.SAL_LEVEL
FROM EMPLOYEE E
JOIN SAL_GRADE ON(SALARY BETWEEN MIN_SAL AND MAX_SAL);

--SELF JOIN--
--자기 자신을 조인하는 방법

--직원의 정보와 직원을 관리하는 매니저의 정보 조회
--ANSI
SELECT E.EMP_ID, E.EMP_NAME, E.MANAGER_ID, E2.EMP_NAME
FROM EMPLOYEE E
JOIN EMPLOYEE E2 ON(E.MANAGER_ID = E2.EMP_ID);

--ORACLE
SELECT E.EMP_ID, E.EMP_NAME, E.MANAGER_ID, E2.EMP_NAME
FROM EMPLOYEE E, EMPLOYEE E2
WHERE E.MANAGER_ID = E2.EMP_ID;

--다중 JOIN--
--여러 개의 테이블을 JOIN하는 것

--ANSI
SELECT EMP_NAME, DEPT_TITLE, LOCAL_NAME
FROM EMPLOYEE
JOIN DEPARTMENT ON(DEPT_CODE = DEPT_ID)
JOIN LOCATION ON(LOCATION_ID = LOCAL_CODE);

--ORACLE
SELECT EMP_NAME, DEPT_TITLE, LOCAL_NAME
FROM EMPLOYEE, DEPARTMENT, LOCATION
WHERE DEPT_CODE = DEPT_ID
        AND LOCATION_ID = LOCAL_CODE;


--실습3
--직급이 대리이면서, 아시아 지역에서 근무하는 사원 조회
--사번, 사원명, 직급명, 부서명, 근무지역명, 급여

SELECT * FROM LOCATION;
SELECT * FROM EMPLOYEE;
SELECT * FROM JOB;
SELECT * FROM DEPARTMENT;
SELECT * FROM NATIONAL;

--ANSI
SELECT EMP_ID, EMP_NAME, JOB_NAME, DEPT_TITLE, LOCAL_NAME, SALARY
FROM EMPLOYEE E
JOIN JOB J ON(E.JOB_CODE = J.JOB_CODE AND JOB_NAME = '대리')
JOIN DEPARTMENT ON(DEPT_CODE = DEPT_ID)
JOIN LOCATION ON(LOCATION_ID = LOCAL_CODE AND LOCAL_NAME LIKE 'ASIA%');

--ORACLE
SELECT EMP_ID, EMP_NAME, JOB_NAME, DEPT_TITLE, LOCAL_NAME, SALARY
FROM EMPLOYEE E, JOB J, DEPARTMENT, LOCATION
WHERE E.JOB_CODE = J.JOB_CODE
       AND DEPT_CODE = DEPT_ID
       AND LOCATION_ID = LOCAL_CODE
       AND JOB_NAME = '대리'
       AND LOCAL_NAME LIKE 'ASIA%';
       

--실습4
--한국과 일본에 근무하는 직원들의 정보를 조회
--사원명, 부서명, 지역명, 국가명
--EMPLOYEE, LOCATION, NATIONAL, DEPARTMENT

--ANSI--
SELECT EMP_NAME, DEPT_TITLE, LOCAL_NAME, NATIONAL_NAME
FROM EMPLOYEE E
JOIN DEPARTMENT D ON(E.DEPT_CODE = D.DEPT_ID)
JOIN LOCATION L ON(D.LOCATION_ID = L.LOCAL_CODE)
JOIN NATIONAL N ON(L.NATIONAL_CODE = N.NATIONAL_CODE)
WHERE NATIONAL_NAME IN('한국', '일본');

--ORACLE--
SELECT EMP_NAME, DEPT_TITLE, LOCAL_NAME, NATIONAL_NAME
FROM EMPLOYEE E , DEPARTMENT D, LOCATION L , NATIONAL N 
WHERE E.DEPT_CODE = D.DEPT_ID
AND D.LOCATION_ID = L.LOCAL_CODE       
AND L.NATIONAL_CODE = N.NATIONAL_CODE
AND NATIONAL_NAME IN('한국','일본');





